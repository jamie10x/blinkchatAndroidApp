package com.jamie.blinkchat.repositories

import com.jamie.blinkchat.core.common.Resource
import com.jamie.blinkchat.domain.model.Message
import com.jamie.blinkchat.domain.model.TypingIndicatorEvent
import kotlinx.coroutines.flow.Flow

interface MessageRepository {

    /**
     * Sends a new message.
     * Handles optimistic UI updates and real-time sending via WebSocket,
     * potentially with a REST fallback.
     *
     * @param content The text content of the message.
     * @param chatId The ID of the chat to send the message to (if known).
     * @param receiverId The ID of the recipient (if starting a new chat or chatId is unknown).
     * @param clientTempId A unique temporary ID generated by the client for this message.
     * @return A Flow emitting the Resource of the sent/optimistic [Message].
     *         It might first emit a success with the optimistic message, then update
     *         upon server acknowledgment or failure.
     */
    fun sendMessage(
        content: String,
        chatId: String?,
        receiverId: String?,
        clientTempId: String
    ): Flow<Resource<out Message>>

    /**
     * Observes messages for a given chat ID from the local database.
     * This flow will automatically update when new messages are received (via WebSocket or REST sync)
     * and saved to the database.
     *
     * @param chatId The ID of the chat.
     * @return A Flow emitting a list of [Message] objects.
     */
    fun getMessagesForChat(chatId: String): Flow<List<Message>>

    /**
     * Fetches older messages for a given chat from the network for pagination.
     * Saves fetched messages to the local database, which will update observers
     * of [getMessagesForChat].
     *
     * @param chatId The ID of the chat.
     * @param beforeTimestamp The timestamp of the oldest currently displayed message (to fetch messages older than this).
     * @param limit The maximum number of messages to fetch.
     * @return A Resource indicating the success or failure of the fetch operation. Data might be Unit or count.
     */
    suspend fun loadOlderMessages(chatId: String, beforeTimestamp: Long, limit: Int): Resource<Int> // Returns number of messages fetched or error

    /**
     * Marks messages in a chat as "delivered" or "read" by sending updates via WebSocket.
     * This would typically be called when the chat screen is opened or messages are scrolled into view.
     *
     * @param chatId The ID of the chat.
     * @param messageIds The list of message IDs to update.
     * @param status The new status (e.g., "delivered", "read").
     */
    suspend fun updateMessageStatus(chatId: String, messageIds: List<String>, status: String)


    /**
     * Listens to real-time events from the WebSocket, such as message acknowledgments,
     * status updates, and new incoming messages, then processes them (e.g., updates local DB).
     * This should be called once when the repository is initialized or when the user is logged in.
     */
    fun observeWebSocketEvents()

    /**
     * Sends a typing indicator status.
     * @param chatId The ID of the chat.
     * @param isTyping True if the current user is typing, false otherwise.
     */
    suspend fun sendTypingIndicator(chatId: String, isTyping: Boolean)

    /**
     * Observes typing indicator events for a specific chat.
     * Emits events only for the given chatId and filters out events from the current user.
     *
     * @param chatId The ID of the chat to observe typing indicators for.
     * @return A Flow emitting [TypingIndicatorEvent] for other users in the chat.
     */

    fun observeTypingIndicators(chatId: String): Flow<TypingIndicatorEvent>

}